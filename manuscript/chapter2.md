# ¿Cómo se ve DevOps?
Si vamos a concentrarnos en el rol de Operaciones de TI en una organización de DevOps, resulta útil pensar en lo que realmente es un proyecto de DevOps. ¿Qué es exactamente lo que provee la operación de TI? ¿Qué capacidades necesita la organización? Vamos a tomar un aspecto de alto nivel en un proyecto al estilo DevOps, y todo lo que esto implica, y vamos a profundizar en varias partes de esto en el resto del libro.

**SIN EMBARGO**, quiero enfatizar que usted no puede lograr DevOps completamente dentro del equipo de Operaciones. _DevOps es pensar en todo el sistema_ (una frase muy Deming), desde las personas que escriben el código hasta las personas que utilizan dicho código, y todo lo demás. El equipo de Operaciones tiene una contribución, al igual que muchos otros equipos y roles.

Hay _un montón de gente hablando de DevOps_ en estos días, por lo que también hay un montón de opiniones diferentes sobre cómo debe funcionar un "proyecto DevOps". En la búsqueda de una explicación concisa y de alto nivel, me quedé bastante impresionado con [una descripción de cómo Spotify](https://labs.spotify.com/2014/03/27/spotify-engineering-culture-part-1/) organiza sus esfuerzos de TI. Aunque gran parte de esa descripción se centra en cómo se organizan los desarrolladores de software, lo interesante para mí fue que el trabajo principal de sus operaciones de TI era crear unidades de automatización para que los desarrolladores pudieran implementar su código directamente en sus ambientes de QA y producción. Las operaciones, en otras palabras, facilitaron una conexión segura y administrada entre desarrolladores y usuarios de aplicaciones (servicios). Ops más o menos arregló las cosas de modo que el mismo Ops "salió del camino", dentro del marco de gestión y control de la actividad.

Este es el corazón de DevOps, y si esto hace que su corazón lata más fuerte, entonces tiene que recordar que DevOps es una filosofía muy diferente de lo que ha hecho antes. En el pasado, los equipos de  QA y de Operaciones eran generalmente equipos separados dentro de TI. El código pasó de los desarrolladores a QA y viceversa, hasta que QA verificó y aprobó, para que luego  Operaciones lo llevará a los ambientes de producción. La intención de tener estas "puertas" entre roles era asegurarse de que nadie hiciera algo que no se suponía que debía hacer, como desplegar código no aprobado en los ambientes de producción. Esto creó varios problemas:

* Developers became lazy. They knew QA was checking their work, and so they concentrated less on producing quality code. QA, in turn, had to take _their_ job more seriously, and so organizations started investing heavily in QA automation. As a result, the organization spent a ton of time and money enabling developers to do their jobs less well. This was good for nobody. Nobody's saying that testing isn't important, just that the dev-versus-QA approach hasn't been massively beneficial or efficient.
* The organization developed a natural us-versus-them attitude, which is probably how _your_ organization behaves right now. At the very least, it's no fun. After all, we're all _supposed_ to have the same goal - delivering software and services to users - so we're supposed to be in it together. In the worst cases, the inter-departmental rivalry becomes truly toxic, making for an unpleasant and unproductive workplace.
* Operations made mistakes simply because _they didn't write the code_, and developers had little incentive to write code that was easy to deploy, manage, or monitor. Developers threw the code "over the wall" and Operations just had to deal with it - increasing the tension between the departments.

All of this conspired to create something that is essentially the antithesis of DevOps. Software releases are slower, because of the implacable march of code from development through to QA, through to production. Operations basically lives in fear of new code, because they know little about it, and it wasn't necessarily designed with ease-of-operating in mind. Slower releases meant more pressure to pack more features into those releases, so each release became a "win," which simply made the process even worse. 

DevOps, by contrast, envisions application and service delivery than constantly pushes small, incremental updates to users, with a minimum of operational overhead. Smaller releases are easier to code and test, and with the right approach, safer to push into production on an ongoing basis. But in order for all that to happen, everyone has to work together. The hard line between developer and operations has to become fuzzy. 

In a DevOps environment, things work differently. Here's a super-simplified look:
1. Developers code, and check their code into a repository.
2. At some point, the repository's current code is pulled and built into an application.
3. Tests - usually automated, and created by developers - are run, including individual models, integration tests, and even user acceptance tests.
4. If the tests succeed, the build is deployed automatically into production (or at least into some deployment cycle).
5. User feedback is collected, feeding the next iteration of the cycle. Return to step 1.

Parts of this can be extremely automated, and parts - like user acceptance - may still be done manually by human beings. The point is that you create as few barriers as possible between coder and user. That _does not mean_ there are no _checkpoints_ along the way - that's what testing is all about, after all - but you don't put one part of the IT team in charge of "stopping" another part "from doing something stupid." DevOps, as a philosophy, implicitly means that you trust your team. If you don't trust someone on your team, you have an HR problem, and you should educate them so that you _do_ trust them, or fire them and replace them with someone you _do_ trust. If your company "would never let a developer's code get into production without thirty other people approving it first," then _you can't do DevOps._ That's what I was writing earlier about management buy-in being the first step.

The idea behind DevOps is, as I've noted, to smooth the path between coder and user, so that small, incremental application updates can be pushed more or less all the time. As user feedback is received, coders respond and updates are pushed. 

Incidentally, [here's a really great explanation of what DevOps is](http://theagileadmin.com/what-is-devops/) - and what it isn't. It's a long article, but it's worth reading, and you'll notice how much management buy-in is needed for all of those things to work.

So, _for the purposes of this book_, we need to look at some of the things needed to make step 4 happen, and a little bit about what's needed in step 3 as well. Again, we're going to focus mainly on processes and practices; you'll definitely need some technology to _implement_ those in real life, but the exact technologies you choose will depend on your specific environment, so we'll keep this a little more abstract for right now.
