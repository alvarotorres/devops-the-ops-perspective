# ¿Cómo se ve DevOps?
Si vamos a concentrarnos en el rol de Operaciones de TI en una organización de DevOps, resulta útil pensar en lo que realmente es un proyecto de DevOps. ¿Qué es exactamente lo que provee la operación de TI? ¿Qué capacidades necesita la organización? Vamos a tomar un aspecto de alto nivel en un proyecto al estilo DevOps, y todo lo que esto implica, y vamos a profundizar en varias partes de esto en el resto del libro.

**SIN EMBARGO**, quiero enfatizar que usted no puede lograr DevOps completamente dentro del equipo de Operaciones. _DevOps es pensar en todo el sistema_ (una frase muy Deming), desde las personas que escriben el código hasta las personas que utilizan dicho código, y todo lo demás. El equipo de Operaciones tiene una contribución, al igual que muchos otros equipos y roles.

Hay _un montón de gente hablando de DevOps_ en estos días, por lo que también hay un montón de opiniones diferentes sobre cómo debe funcionar un "proyecto DevOps". En la búsqueda de una explicación concisa y de alto nivel, me quedé bastante impresionado con [una descripción de cómo Spotify](https://labs.spotify.com/2014/03/27/spotify-engineering-culture-part-1/) organiza sus esfuerzos de TI. Aunque gran parte de esa descripción se centra en cómo se organizan los desarrolladores de software, lo interesante para mí fue que el trabajo principal de sus operaciones de TI era crear unidades de automatización para que los desarrolladores pudieran implementar su código directamente en sus ambientes de QA y producción. Las operaciones, en otras palabras, facilitaron una conexión segura y administrada entre desarrolladores y usuarios de aplicaciones (servicios). Ops más o menos arregló las cosas de modo que el mismo Ops "salió del camino", dentro del marco de gestión y control de la actividad.

Este es el corazón de DevOps, y si esto hace que su corazón lata más fuerte, entonces tiene que recordar que DevOps es una filosofía muy diferente de lo que ha hecho antes. En el pasado, los equipos de  QA y de Operaciones eran generalmente equipos separados dentro de TI. El código pasó de los desarrolladores a QA y viceversa, hasta que QA verificó y aprobó, para que luego  Operaciones lo llevará a los ambientes de producción. La intención de tener estas "puertas" entre roles era asegurarse de que nadie hiciera algo que no se suponía que debía hacer, como desplegar código no aprobado en los ambientes de producción. Esto creó varios problemas:

* Los desarrolladores se volvieron perezosos. Sabían que QA estaba revisando su trabajo, por lo que  se concentraron menos en producir código de calidad. QA, a su vez, tuvo que tomar su trabajo más en serio, por lo que las organizaciones comenzaron a invertir mucho en la automatización de controles de calidad. Como resultado, la organización gastó una tonelada de tiempo y dinero permitiendo a los desarrolladores hacer sus trabajos con menor calidad. Esto no era bueno para nadie. Es evidente que las pruebas son importantes, pero el enfoque dev-versus-QA no ha sido masivamente beneficioso ni eficiente.

* La organización desarrolló una actitud “anti-nosotros”, que es probablemente como su organización se comporta ahora mismo. Pero eso no es divertido. Después de todo, _se supone que todos tenemos el mismo objetivo_: ofrecer software y servicios a los usuarios, por lo que se supone que debemos estar juntos. En los peores casos, la rivalidad interdepartamental se vuelve verdaderamente tóxica, lo que lleva a que el lugar de trabajo se convierta en algo desagradable e improductivo.

* Operaciones cometió algunos errores simplemente porque _ellos no escribieron el código_, y los desarrolladores tenían poco incentivo para escribir código que fuera fácil de implementar, administrar o supervisar. Los desarrolladores simplemente lanzaron el código "al otro lado del muro" y Operaciones tuvo que lidiar con él - aumentando la tensión entre los departamentos.


All of this conspired to create something that is essentially the antithesis of DevOps. Software releases are slower, because of the implacable march of code from development through to QA, through to production. Operations basically lives in fear of new code, because they know little about it, and it wasn't necessarily designed with ease-of-operating in mind. Slower releases meant more pressure to pack more features into those releases, so each release became a "win," which simply made the process even worse. 

DevOps, by contrast, envisions application and service delivery than constantly pushes small, incremental updates to users, with a minimum of operational overhead. Smaller releases are easier to code and test, and with the right approach, safer to push into production on an ongoing basis. But in order for all that to happen, everyone has to work together. The hard line between developer and operations has to become fuzzy. 

In a DevOps environment, things work differently. Here's a super-simplified look:
1. Developers code, and check their code into a repository.
2. At some point, the repository's current code is pulled and built into an application.
3. Tests - usually automated, and created by developers - are run, including individual models, integration tests, and even user acceptance tests.
4. If the tests succeed, the build is deployed automatically into production (or at least into some deployment cycle).
5. User feedback is collected, feeding the next iteration of the cycle. Return to step 1.

Parts of this can be extremely automated, and parts - like user acceptance - may still be done manually by human beings. The point is that you create as few barriers as possible between coder and user. That _does not mean_ there are no _checkpoints_ along the way - that's what testing is all about, after all - but you don't put one part of the IT team in charge of "stopping" another part "from doing something stupid." DevOps, as a philosophy, implicitly means that you trust your team. If you don't trust someone on your team, you have an HR problem, and you should educate them so that you _do_ trust them, or fire them and replace them with someone you _do_ trust. If your company "would never let a developer's code get into production without thirty other people approving it first," then _you can't do DevOps._ That's what I was writing earlier about management buy-in being the first step.

The idea behind DevOps is, as I've noted, to smooth the path between coder and user, so that small, incremental application updates can be pushed more or less all the time. As user feedback is received, coders respond and updates are pushed. 

Incidentally, [here's a really great explanation of what DevOps is](http://theagileadmin.com/what-is-devops/) - and what it isn't. It's a long article, but it's worth reading, and you'll notice how much management buy-in is needed for all of those things to work.

So, _for the purposes of this book_, we need to look at some of the things needed to make step 4 happen, and a little bit about what's needed in step 3 as well. Again, we're going to focus mainly on processes and practices; you'll definitely need some technology to _implement_ those in real life, but the exact technologies you choose will depend on your specific environment, so we'll keep this a little more abstract for right now.
